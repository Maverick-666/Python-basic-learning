# 第1题
"""
没啥好说的，菜就多练哈哈哈
"""
# 第2题
"""
因为很显然当一个因子小于目标数的根号时，假设它能整除目标数
那么得到的另一个数一定大于目标数的根号
所以超过目标数根号的那个部分相当于重复了
"""
# 第3题
"""
不完全等价
因为原来的式子中a变成了b，而b变成了原来的a+b，相当于是无缝衔接
但是另一个写法的a已经变成了b，b后面相当于是变成了2b，不一样
"""
# 第4题
"""
假设n是三位数
个位：n%10
十位: n//10%10
百位: n//100
"""
# 第5题
"""
终止条件是当num=0的时候
reversed_num = reversed_num * 10 + num % 10
这一行代码相当于一个传送带，把先运输进来的（个位）x10，再把后面进来的下一位（十位）引进来当成反转数的个位
这样下次运行的时候，原来的个位继续x10变成百位，原来的十位x10变成十位，再引进原来的百位变成个位
"""
# 第6题
"""
暴力对三方都达成的情况进行搜索
优点是代码非常容易看懂
缺点是时间复杂度太大，对于很大的数据花费时间很长
"""
# 第7题
"""
三层循环的时间复杂度是n三次方
二层循环是n平方
核心思想是巧妙利用题目，将一个变量用另外两个变量进行表达，这样相当于第二层循环包含两个变量的判断
而每一层的判断都是线性的
"""
# 第8题
"""
记录当前的点数，作为目标点数
"""
# 第9题
"""
打印5行
* ** *** **** *****
"""
for _ in range(6):
    for i in range(6):
        print(i*'*',end=" ")
    print()
# 第10题
lst = [1,2,3,4]
Sum = 0
for i in lst:
    for j in lst:
        for k in lst:
            if i!=j and i!=k and j!=k:
                print(i*100+j*10+k)
                Sum = Sum+1
print(f'一共有{Sum}种')
# 第11题
"""
需要考虑时间复杂度，循环嵌套的层数
"""
# 第12题
"""
与预期不符的时候我可以
1、利用debug，打断点一步一步执行，检查变量的值
2、在每个逻辑点进行相关变量的输出，检查是否符合预期
"""
# 第13题
"""
可读性我个人认为没有提高
没有三层嵌套的直观
因为三层比较无脑一些，而优化版本需要动脑，也就是有注释的必要性
"""
# 第14题
"""
跟range一样[1,7)左闭右开，取不到7，到6
如果是1，6最大是5
"""
# 第15题
"""
从递归或者递推可以看出来
f(n) = f(n-1) + f(n-2)
那么很显然是n-1和n-2
"""