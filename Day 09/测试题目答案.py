# 第1题
"""
特性一：不重复性 集合中的元素不重复，适用于处理大量数据并统计种类
特性二：确定性 一个元素要么在集合中要么不在
特性三：无序性 不能用索引，元素在集合中的位置是随机的
"""
# 第2题
my_set = set([1,'a',True])
"""
但是1和True不就重复了吗，我不太懂
"""
void_set = ()
void_dict = {}
print(type(void_dict)) #因为是字典属性的
"""
题目中data = 后面的内容没有展现出来
我假设是 data = [1,2,3,(1,2,3)]
"""
data = [1,2,3,(1,2,3)]
print(set(data))
# 第3题
"""
集合底层使用哈希表（Hash Table）来存储元素
以实现快速的成员查找和去重。
哈希表依赖于元素的哈希值（一个固定的整数）来确定其存储位置。
如果一个对象是可变的，它的内容改变后哈希值可能会改变，
这将破坏哈希表的结构。
因此，只有哈希值固定不变的对象（即不可变对象）才能作为集合元素或字典键。
这与是否有索引关系不大


可哈希类型通常指不可变类型，比如集合，字典的键
如果将一个列表作为集合的元素，会发生报错
"""
# 第4题
"""
不能，因为集合是无序的
可以通过 for element in set:来遍历
"""
# 第5题
s1 = {1, 2, 3, 4}
s2 = {3, 4, 5, 6}
print(s1 & s2)
print(s1.intersection(s2))
print(s1 | s2)
print(s1.union(s2))
# 第6题
"""
s1 - s2的结果是{1,2}表示差集
s1 ^ s2的结果是{1,2,5,6}表示对称差
"""
# 第7题
"""
内容不变，因为集合中已经存在元素2，集合有不重复性
"""
# 第8题
"""
remove()方法找不到对应元素会报错
discard()找不到无事发生
"""
# 第9题
"""
set.pop()方法随机删除一个元素并得到这个元素
集合为空，则报错
"""
# 第10题
a = {1, 2}
b= {1, 2, 3}
print(a < b) # 表示a是b的子集
print(b>=a) # 表示b是a的超集
# 第11题
"""
frozenset与set区别在于前者不能修改集合内元素，是可哈希类型，但set可修改，不可哈希
"""
# 第12题
lst = [1,2,3,3,2,4]
print(list(set(lst)))
# 第13题
user1_movies = ['Avengers', 'Joker', 'Parasite']
user2_movies = ['Parasite', 'Knives Out', 'Joker']
print(set(user1_movies) & set(user2_movies))
# 第14题
print({i for i in range(1,21) if i % 2 == 0 and i % 3 != 0})
# 第15题
"""
那必须是使用工具的时候能够做到顾名思义，直接利用数学里的运算进行集合运算，非常省事
"""