**1. 核心概念：装饰器的本质**

- 请用你自己的话解释Python装饰器是什么，并说明为什么它被认为是一种高阶函数。
    

**2. 装饰器：基本结构 wrapper**

- 在一个典型的装饰器函数内部，通常会定义一个名为 wrapper (或其他类似名称) 的内部函数。这个 wrapper 函数的主要作用是什么？它如何接收传递给被装饰函数的参数？
    

**3. 装饰器：@ 语法糖**

- 如果有一个装饰器函数 my_decorator 和一个普通函数 say_hello，语句 say_hello = my_decorator(say_hello) 和使用 @my_decorator 语法糖在 say_hello 定义之上，它们在效果上有什么关系？
    

**4. functools.wraps 的作用**

- 在定义装饰器时，为什么推荐在 wrapper 函数上使用 @functools.wraps(func) 这个装饰器？它能解决什么问题？
    

**5. 调用被装饰前的原函数**

- 如果一个函数 original_func 被装饰器（该装饰器内部使用了 @wraps(original_func)）装饰后变成了 decorated_func，如何通过 decorated_func 来调用未被装饰的 original_func？
    

**6. 核心概念：递归的两个要素**

- 一个正确的递归函数必须包含哪两个基本要素？如果缺少了其中一个或两个，可能会导致什么问题？
    

**7. 递归：阶乘示例 factorial(n)**

- 在递归计算阶乘的函数 factorial(n) 中：
    
    - if n in (0, 1): return 1 这部代码扮演了递归中的什么角色？
        
    - return n * factorial(n - 1) 这部分代码扮演了递归中的什么角色？
        

**8. 递归：栈溢出 RecursionError**

- 为什么递归调用次数过多会导致 RecursionError (栈溢出)？
    

**9. 递归与迭代：斐波那契数列**

- 计算斐波那契数列时，直接的递归实现（未优化）与使用循环递推的方式相比，在性能上通常有何差异？为什么会产生这种差异？
    

**10. @lru_cache 装饰器：作用与原理**  
* @functools.lru_cache() 装饰器的主要作用是什么？它是如何提高递归函数（如计算斐波那契数列）的性能的？

**11. 装饰器应用场景思考**  
* 除了本单元示例中的记录函数执行时间，请再设想至少两个你认为可以使用装饰器来增强函数功能的场景。

**12. 递归应用场景思考**  
* 除了计算阶乘和斐波那契数列，请再列举一个适合使用递归来解决的问题或算法。

**13. 装饰器与原函数的参数传递**  
* 在装饰器的 wrapper 函数定义中，为什么通常使用 *args 和 **kwargs 作为参数？

**14. 递归的替代方案**  
* 当一个问题可以用递归解决，但存在栈溢出风险或性能问题时，通常可以考虑将其转换为哪种非递归的实现方式？

**15. 思考题：装饰器的“副作用”**  
* 虽然装饰器可以透明地增强函数功能，但在某些情况下，如果使用不当（例如没有使用 functools.wraps），它可能会对被装饰函数的一些元信息（如 __name__, __doc__）产生什么影响？

---