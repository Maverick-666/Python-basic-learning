# 第1题
"""
python 装饰器的本质也是一种函数，但是他的作用在于可以在原函数的功能上新增特定的功能
而且装饰器能够重复在不同的函数上使用
"""
# 第2题
"""
wapper函数的作用是装饰源函数，添加很多功能
1、首先装饰器收到目标函数，2、然后进入到wapper函数中进行对源函数的处理
3、接下来用户输入的数据都是传入wapper函数，4、然后wapper函数中内嵌源函数的调用
5、把数据传给源函数得到结果，除此之外wapper函数自己还自带很多功能，这就是装饰的功能
"""
# 第3题
"""
效果上相同
"""
# 第4题
"""
@functools.wraps(func)这个装饰器能够保留源函数的元信息
如__name__，__doc__等
这样就能通过func_to_decorate.__name__的魔法方法直接取得名字
"""
# 第5题
"""
如果已经被调用了，那么可以用decorated_func.__wrapped__()的方法
"""
# 第6题
"""
正确的递归包括：
1、有收敛条件
2、不能递归太深，有栈溢出风险
"""
# 第7题
"""
 if n in (0, 1): return 1  这部分代码扮演了递归中基本情况/收敛条件
 return n * factorial(n - 1) 这部分代码扮演了调用函数自身（递归）的过程
"""
# 第8题
"""
因为每递归一次系统就会产生新的栈空间，而在达到基本情况进行反推的时候，系统才会自动收回
而总的栈空间是有限的，创造过多会导致栈溢出
"""
# 第9题
"""
时间上会相差很多，因为未优化的递归树上相同的子节点会被计算多次，导致大量的重复计算
而循环递推的方式是线性的，它只需要考虑上一项和目前项就能得到下一项
"""
# 第10题
"""
@functools.lru_cache()装饰器的作用是缓存调用，他会把计算过的子节点进行保存
这样遇到相同子节点时就可以直接代入数值
"""
# 第11题
"""
1、我之前自己尝试开发网站的时候使用过@jwt_required()装饰器，能有助于检查某个人是否被授权去使用一个web应用的端点
2、还有就比如说装饰器可以用来打印函数日志
"""
# 第12题
"""
所有深度搜索算法都要用到递归
"""
# 第13题
"""
因为确保能接受到用户的所有传入的数据
"""
# 第14题
"""
递推，或者通过打表
"""
# 第15题
"""
可能会让被装饰的函数的一些元信息被修改
"""
